import * as pdfjsLib from 'pdfjs-dist';
import mammoth from 'mammoth';
import { analyzeResumeWithAI, parseStructuredDataWithAI, matchJobDescriptionWithAI } from './aiService';
import { validateResumeData, calculateCompletenessScore, calculateConfidenceScores, analyzeDataQuality } from './validationService';

// Configure worker to avoid CDN issues - use matching version
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

// Memoization utility for expensive operations
const memoize = (fn, resolver) => {
  const cache = new Map();
  const MAX_MEMO_SIZE = 50;
  
  return function(...args) {
    const key = resolver ? resolver(...args) : JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    // Clean cache if too large
    if (cache.size >= MAX_MEMO_SIZE) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
};

// AI Extraction Helper with Retry Logic and Fallbacks
const attemptAIExtraction = async (content, maxRetries = 3) => {
  console.log("Starting AI Data Extraction with retry logic...");
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`AI Extraction Attempt ${attempt}/${maxRetries}`);
      
      // Try backend service first (preferred)
      try {
        const response = await fetch(`${process.env.REACT_APP_API_URL || '/api'}/ai/parse-structured`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ rawText: content })
        });

        if (response.ok) {
          const data = await response.json();
          console.log("Backend AI service successful");
          return { success: true, data: data.data };
        } else {
          console.warn(`Backend AI service failed (attempt ${attempt}):`, response.statusText);
        }
      } catch (backendError) {
        console.warn(`Backend AI service error (attempt ${attempt}):`, backendError.message);
      }

      // Fallback to direct AI service
      console.log("Falling back to direct AI service...");
      const directResult = await parseStructuredDataWithAI(content);
      console.log("Direct AI service successful");
      return { success: true, data: directResult };
      
    } catch (error) {
      console.error(`AI Extraction attempt ${attempt} failed:`, error.message);
      
      // If this is the last attempt, return failure
      if (attempt === maxRetries) {
        return { 
          success: false, 
          error: `AI extraction failed after ${maxRetries} attempts: ${error.message}` 
        };
      }
      
      // Wait before retry (exponential backoff)
      const delay = Math.pow(2, attempt - 1) * 1000; // 1s, 2s, 4s
      console.log(`Waiting ${delay}ms before retry...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
};

// Main education extraction function
const extractEducationFromFile = memoize((content) => {
  console.log("Debug - Education extraction input preview:", content.substring(0, CONFIG.maxContentPreviewLength));
  
  // Try industry-specific education extraction first
  const educationFunctions = [
    extractHealthcareEducationFromFile,
    extractEducationEducationFromFile,
    extractBusinessEducationFromFile,
    extractEngineeringEducationFromFile,
    extractCreativeEducationFromFile,
    extractGenericEducation
  ];
  
  for (const func of educationFunctions) {
    try {
      const result = func(content);
      if (result && result.length > 0) {
        console.log(`Debug - Education entries found via ${func.name}:`, result);
        return result;
      }
    } catch (error) {
      console.error(`Error in ${func.name}:`, error);
    }
  }
  
  console.log("Debug - No education entries found");
  return [];
});

// Configuration constants
const CONFIG = {
  maxExperienceEntries: 10,
  minSkillLength: 2,
  maxSkillLength: 50,
  confidenceThresholds: {
    high: 0.8,
    medium: 0.5,
    low: 0.3
  },
  maxContentPreviewLength: 200
};

// Enhanced Regex Caching with Cleanup Strategy
const REGEX_CACHE = {};
const MAX_CACHE_SIZE = 100;
const CACHE_CLEANUP_THRESHOLD = 80; // Clean when 80% full

const getCachedRegex = (pattern, flags = 'gi') => {
  const key = `${pattern}_${flags}`;
  
  if (!REGEX_CACHE[key]) {
    // Clean cache if it's getting too large
    const cacheKeys = Object.keys(REGEX_CACHE);
    if (cacheKeys.length >= CACHE_CLEANUP_THRESHOLD) {
      cleanupRegexCache();
    }
    
    REGEX_CACHE[key] = new RegExp(pattern, flags);
  }
  return REGEX_CACHE[key];
};

const cleanupRegexCache = () => {
  console.log(`Cleaning up regex cache. Current size: ${Object.keys(REGEX_CACHE).length}`);
  
  // Remove oldest entries (FIFO approach)
  const cacheKeys = Object.keys(REGEX_CACHE);
  const entriesToRemove = Math.floor(cacheKeys.length * 0.3); // Remove 30%
  
  for (let i = 0; i < entriesToRemove; i++) {
    delete REGEX_CACHE[cacheKeys[i]];
  }
  
  console.log(`Cache cleanup complete. New size: ${Object.keys(REGEX_CACHE).length}`);
};

// Enhanced error handling with comprehensive boundaries
const createErrorBoundary = (operationName) => {
  return async (asyncFunction, fallbackValue = null) => {
    try {
      const result = await asyncFunction();
      return result;
    } catch (error) {
      console.error(`Error in ${operationName}:`, error);
      
      // Log detailed error information
      const errorInfo = {
        operation: operationName,
        timestamp: new Date().toISOString(),
        error: error.message,
        stack: error.stack
      };
      
      // Store error for debugging
      if (typeof window !== 'undefined' && window.resumeParserErrors) {
        window.resumeParserErrors.push(errorInfo);
      }
      
      return fallbackValue;
    }
  };
};

// Enhanced safe extraction with retry logic
const safeExtractWithRetry = async (func, defaultValue, maxRetries = 3, ...args) => {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const result = await Promise.resolve(func(...args));
      return result || defaultValue;
    } catch (error) {
      console.error(`Error in ${func.name} (attempt ${attempt}/${maxRetries}):`, error);
      
      if (attempt === maxRetries) {
        console.error(`Max retries reached for ${func.name}. Returning default value.`);
        return defaultValue;
      }
      
      // Exponential backoff
      const delay = Math.pow(2, attempt - 1) * 500; // 500ms, 1s, 2s
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
};

// Validation helper functions
const isValidEmail = (email) => {
  if (typeof email !== 'string') return false;
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  return emailRegex.test(email);
};

const isValidPhone = (phone) => {
  if (typeof phone !== 'string') return false;
  const cleanPhone = phone.replace(/\D/g, '');
  return cleanPhone.length >= 10 && cleanPhone.length <= 15;
};

// Helper function to escape special regex characters
const escapeRegExp = (string) => {
  return string.replace(/[.*+?^${}()|\[\]\\]/g, '\$&');
};

/**
 * Resume Parser Service
 * Handles parsing of resume files (PDF, DOCX) to extract structured data
 */

// Advanced resume parsing service with improved text extraction algorithms
const parseResume = async (file) => {
  try {
    let fileContent = '';

    // Determine file type and extract text accordingly
    if (file.type === 'application/pdf') {
      fileContent = await extractTextFromPDF(file);
    } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
      file.name.endsWith('.docx')) {
      fileContent = await extractTextFromDOCX(file);
    } else if (file.type === 'text/plain' || file.name.endsWith('.txt')) {
      fileContent = await readFileAsText(file);
    } else {
      throw new Error('Unsupported file format. Please upload PDF, DOCX, or TXT.');
    }

    // If no text was extracted (likely a scanned image), try OCR
    if (!fileContent || fileContent.trim().length < 20) {
      if (file.type === 'application/pdf') {
        console.log('Attempting OCR on PDF...');
        fileContent = await runOCROnPDF(file);
        if (!fileContent || fileContent.trim().length < 20) {
          throw new Error('The document appears to be a scanned image with no readable text. OCR service may be needed.');
        }
      } else {
        throw new Error('The document appears to be empty or unreadable. Please ensure it is not a scanned image.');
      }
    }

    console.log("Extracted Text Preview:", fileContent.substring(0, CONFIG.maxContentPreviewLength));
    
    let aiExtractedData = {};
    
    // 1. Try AI Extraction with comprehensive error handling and retry logic
    const aiExtractionResult = await attemptAIExtraction(fileContent);
    if (aiExtractionResult.success) {
      aiExtractedData = aiExtractionResult.data;
      console.log("AI Extraction Complete", aiExtractedData);
    } else {
      console.warn("AI Extraction failed, falling back to regex:", aiExtractionResult.error);
    }
        
    // 2. Section-based extraction approach
    console.log("Using section-based extraction...");
    
    // First, identify sections in the resume
    const sections = identifyResumeSections(fileContent);
    console.log("Identified sections:", Object.keys(sections));
    
    // Use section-specific content for extraction where available
    const contentForExtraction = sections.other || fileContent; // Use unassigned content as fallback
    const educationContent = sections.education || contentForExtraction;
    const experienceContent = sections.experience || contentForExtraction;
    const skillsContent = sections.skills || contentForExtraction;
    const contactContent = sections.contact || fileContent;
    
    // Extract individual fields with enhanced error handling and retry logic
    const email = await safeExtractWithRetry(extractEmailFromFile, null, 3, contactContent);
    const phone = await safeExtractWithRetry(extractPhoneFromFile, null, 3, contactContent);
    
    console.log("Debug - Extracted Email:", email);
    console.log("Debug - Extracted Phone:", phone);
    
    const regexData = {
      name: await safeExtractWithRetry(extractNameFromContent, null, 3, contactContent),
      email: email,
      phone: phone,
      address: await safeExtractWithRetry(extractLocationFromFile, null, 3, contactContent),
      experience: await safeExtractWithRetry(extractExperienceFromFile, [], 3, experienceContent),
      education: await safeExtractWithRetry(extractEducationFromFile, [], 3, educationContent),
      skills: {
        technical: await safeExtractWithRetry(extractTechnicalSkillsFromFile, [], 3, skillsContent),
        soft: await safeExtractWithRetry(extractSoftSkillsFromFile, [], 3, skillsContent),
        education: await safeExtractWithRetry(extractEducationSkillsFromFile, [], 3, skillsContent),
        business: await safeExtractWithRetry(extractBusinessSkillsFromFile, [], 3, skillsContent)
      },
      certifications: await safeExtractWithRetry(extractCertificationsFromFile, [], 3, sections.certifications || contentForExtraction),
      summary: await safeExtractWithRetry(extractSummaryFromFile, null, 3, sections.profile || contentForExtraction),
      projects: await safeExtractWithRetry(extractProjectsFromFile, [], 3, sections.projects || contentForExtraction),
      languages: await safeExtractWithRetry(extractLanguagesFromFile, [], 3, sections.languages || contentForExtraction),
      github: await safeExtractWithRetry(extractGithubFromFile, null, 3, contactContent),
      linkedin: await safeExtractWithRetry(extractLinkedinFromFile, null, 3, contactContent),
      interests: await safeExtractWithRetry(extractInterestsFromFile, [], 3, sections.interests || contentForExtraction)
    };
    
    console.log("Debug - Regex Data:", regexData);

    // Intelligent Merge: prioritize AI but fill empty fields with regex
    const finalData = { ...regexData };

    const isMeaningful = (val) => {
      if (val === null || val === undefined) return false;
      if (typeof val === 'string') {
        const lower = val.toLowerCase().trim();
        return !['', 'null', 'unknown', 'n/a', 'not provided', 'undefined', 'string', 'none'].includes(lower);
      }
      if (Array.isArray(val)) return val.length > 0;
      if (typeof val === 'object') return Object.keys(val).length > 0;
      return true;
    };
        
    if (aiExtractedData) {
      Object.keys(aiExtractedData).forEach(key => {
        const val = aiExtractedData[key];
        if (key === 'skills' && val) {
          if (isMeaningful(val.technical)) finalData.skills.technical = val.technical;
          if (isMeaningful(val.soft)) finalData.skills.soft = val.soft;
        } else if (key === 'email') {
          if (isValidEmail(val)) finalData.email = val;
        } else if (key === 'phone') {
          if (isValidPhone(val)) finalData.phone = val;
        } else if (isMeaningful(val)) {
          finalData[key] = val;
        }
      });
    }

    const parsedData = {
      fileName: file.name,
      fileSize: (file.size / 1024).toFixed(2) + ' KB',
      rawText: fileContent,
      extractedData: finalData,
      extractionConfidence: aiExtractedData ? 0.95 : 0.6,
      extractionMetadata: {
        method: aiExtractedData ? 'AI-Augmented' : 'Heuristic-Only',
        timestamp: new Date().toISOString(),
        sectionsIdentified: Object.keys(finalData).filter(k => isMeaningful(finalData[k])),
        formattingQuality: 'analyzing',
        completenessScore: 0,
        extractionErrors: [],
        validationIssues: []
      }
    };

    // Enhanced validation with comprehensive quality checks
    const validationResults = validateResumeData(parsedData);
    const qualityAnalysis = analyzeDataQuality(parsedData);
    
    // Add validation results to metadata
    parsedData.extractionMetadata.validationResults = validationResults;
    parsedData.extractionMetadata.qualityAnalysis = qualityAnalysis;
    parsedData.extractionMetadata.completenessScore = validationResults.qualityScore;
    
    // Add detailed error information
    if (validationResults.errors.length > 0) {
      parsedData.extractionMetadata.validationIssues = validationResults.errors;
    }
    if (qualityAnalysis.hasIssues) {
      parsedData.extractionMetadata.qualityIssues = qualityAnalysis.issues;
    }
    
    // Calculate confidence scores using the new service
    parsedData.confidence = calculateConfidenceScores(parsedData);

    return parsedData;
  } catch (error) {
    console.error("Critical Resume Parsing Error:", error);
    throw error;
  }
};

// Calculate confidence scores for extracted data
// Using imported calculateConfidenceScores function from validationService

// Helper to extract text from PDF using pdfjs-dist with improved error handling
const extractTextFromPDF = async (file) => {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    let text = '';

    for (let i = 1; i <= pdf.numPages; i++) {
      try {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const strings = content.items.map(item => item.str);
        text += strings.join('\n') + '\n';
      } catch (pageError) {
        console.warn(`Failed to extract text from page ${i}:`, pageError);
        continue;
      }
    }

    return text;
  } catch (error) {
    console.error('PDF text extraction failed:', error);
    // Return empty string instead of throwing
    return '';
  }
};

// Helper to extract text from DOCX using mammoth
const extractTextFromDOCX = async (file) => {
  const arrayBuffer = await file.arrayBuffer();
  const result = await mammoth.extractRawText({ arrayBuffer });
  return result.value;
};

// Fallback OCR function for scanned PDFs with improved error handling
const runOCROnPDF = async (file) => {
  try {
    console.log('Calling backend OCR service...');

    const formData = new FormData();
    formData.append('file', file);

    const response = await fetch(`${process.env.REACT_APP_API_URL || '/api'}/resume/ocr`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`OCR service failed with status ${response.status}: ${errorText}`);
    }

    const result = await response.json();
    
    if (!result.success || !result.data || !result.data.text) {
      throw new Error('OCR service returned invalid response format');
    }
    
    return result.data.text;
  } catch (error) {
    console.error('OCR service error:', error);
    throw new Error(`OCR processing failed: ${error.message}`);
  }
};

// Helper to read simple text files
const readFileAsText = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (event) => resolve(event.target.result);
    reader.onerror = (error) => reject(error);
    reader.readAsText(file);
  });
};

// Enhanced name extraction with multiple patterns
const extractNameFromContent = (content) => {
  const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0);
  if (lines.length === 0) return null;

  // Strategy 1: Look for prominent name patterns at the top
  for (let i = 0; i < Math.min(lines.length, 8); i++) {
    const line = lines[i];

    // Skip if it looks like a header or section title
    if (/^(CURRICULUM|RESUME|CV|CONTACT|PROFILE|EXPERIENCE|ABOUT|EDUCATION|SKILLS|PROJECTS|CERTIFICATES?|AWARDS?|INTERESTS?)/i.test(line)) continue;

    // Pattern: Full name with proper capitalization (most common)
    // Support international names with accented characters
    if (/^[A-ZÃ€-Ã¿][a-zÃ -Ã¿]+\s+[A-ZÃ€-Ã¿][a-zÃ -Ã¿]+(?:\s+[A-ZÃ€-Ã¿][a-zÃ -Ã¿]*)?$/.test(line)) {
      return line.trim();
    }

    // Pattern: ALL CAPS name (e.g. JOHN DOE)
    if (/^[A-ZÃ€-Å¸]+\s+[A-ZÃ€-Å¸]+(?:\s+[A-ZÃ€-Å¸]+)?$/.test(line) && line.split(' ').length <= 4) {
      return line.split(' ').map(word => word.charAt(0) + word.slice(1).toLowerCase()).join(' ');
    }

    // Pattern: Name with potential title (Mr., Ms., Dr., etc.)
    if (/^(MR\.?|MS\.?|MRS\.?|DR\.?|MISS|MR|MRS)\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/i.test(line)) {
      const match = line.match(/(MR\.?|MS\.?|MRS\.?|DR\.?|MISS|MR|MRS)\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/i);
      if (match) return match[2].trim();
    }

    // Pattern: Name with initials
    if (/^[A-Z]\.[A-Z]\.[A-Z][a-z]+/.test(line) || /^[A-Z][a-z]+\s+[A-Z]\.[A-Z]\./.test(line)) {
      return line.replace(/\s*[,.]?\s*/, ' ').trim();
    }
  }

  // Strategy 2: Look for name near contact info
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // If we find email/phone, check surrounding lines for name
    if (line.includes('@') || /\d{3}[-.]?\d{3}[-.]?\d{4}/.test(line)) {
      // Check previous lines
      for (let j = Math.max(0, i - 3); j < i; j++) {
        const prevLine = lines[j];
        if (/^[A-Z][a-z]+\s+[A-Z][a-z]+/.test(prevLine) && !prevLine.includes('INC') && !prevLine.includes('LLC')) {
          return prevLine.trim();
        }
      }
    }
  }

  return null;
};

// Enhanced email extraction with validation
const extractEmailFromFile = memoize((content) => {
  console.log("Debug - Email extraction input preview:", content.substring(0, 500));
  
  // Preprocess content to handle encoded emails and icons
  let processedContent = content
    .replace(/\[dot\]/gi, '.')
    .replace(/\[at\]/gi, '@')
    .replace(/\(dot\)/gi, '.')
    .replace(/\(at\)/gi, '@')
    .replace(/\{dot\}/gi, '.')
    .replace(/\{at\}/gi, '@')
    .replace(/âœ‰ï¸|ðŸ“§/g, '')
    .replace(/\s+/g, ' '); // Normalize whitespace

  // More comprehensive email patterns to catch full emails
  const emailPatterns = [
    // Standard email formats with various TLDs
    /\b[\w\.\-\+]+@[\w\.\-]+\.[a-zA-Z]{2,}(?:\.[a-zA-Z]{2,})?\b/gi,
    
    // Emails with common domains
    /\b[\w\.\-\+]+@(?:gmail|yahoo|outlook|hotmail|icloud|protonmail)\.com\b/gi,
    
    // Encoded emails with various separators
    /\b([\w\.\-\+_]+)\s*(?:\[at\]|\(at\)|\{at\}|@)\s*([\w\.\-]+)\s*(?:\[dot\]|\(dot\)|\{dot\}|\.)\s*([a-zA-Z]{2,}(?:\.[a-zA-Z]{2,})?)\b/gi,
    
    // Emails with spaces in encoding
    /\b([\w\.\-\+_]+)\s+at\s+([\w\.\-]+)\s+dot\s+([a-zA-Z]{2,}(?:\.[a-zA-Z]{2,})?)\b/gi,
    
    // Emails in common formats found in resumes
    /Email\s*[:\-]?\s*([\w\.\-\+]+@[\w\.\-]+\.[a-zA-Z]{2,})/gi,
    /E-?mail\s*[:\-]?\s*([\w\.\-\+]+@[\w\.\-]+\.[a-zA-Z]{2,})/gi
  ];

  const allMatches = [];
  
  // Apply all patterns
  for (const pattern of emailPatterns) {
    const matches = [...processedContent.matchAll(pattern)];
    for (const match of matches) {
      if (match.length >= 2) {
        // Handle capture groups (encoded emails)
        const email = match.length > 1 ? match[1] : match[0];
        if (email && !email.includes('@') && match.length >= 4) {
          // Reconstruct encoded email
          allMatches.push(`${match[1]}@${match[2]}.${match[3]}`);
        } else if (email) {
          allMatches.push(email);
        }
      }
    }
  }

  console.log("Debug - Raw email matches found:", allMatches);
  
  // Deduplicate and clean matches
  const uniqueEmails = [...new Set(allMatches.map(email => email.trim().toLowerCase()))]
    .map(email => email.trim())
    .filter(email => {
      // Basic validation
      if (!email.includes('@')) return false;
      
      const parts = email.split('@');
      if (parts.length !== 2) return false;
      
      const [local, domain] = parts;
      if (!local || !domain || local.length < 1 || domain.length < 3) return false;
      
      // Check for valid TLD pattern
      const tldPattern = /\.[a-zA-Z]{2,}(?:\.[a-zA-Z]{2,})?$/;
      if (!tldPattern.test(domain)) return false;
      
      // Exclude obvious false positives
      const falsePositives = ['instagram', 'twitter', 'facebook', 'linkedin', 'github'];
      // Only exclude if the local part exactly matches these terms (not partial matches)
      if (falsePositives.includes(local.toLowerCase())) return false;
      
      return true;
    });

  console.log("Debug - Valid unique emails:", uniqueEmails);
  
  if (uniqueEmails.length > 0) {
    // Return the most likely personal email
    const personalEmails = uniqueEmails.filter(email => {
      const domain = email.split('@')[1].toLowerCase();
      return !domain.includes('company') && 
             !domain.includes('inc') && 
             !domain.includes('corp') && 
             (domain.includes('gmail') || 
              domain.includes('yahoo') || 
              domain.includes('outlook') || 
              domain.includes('hotmail') ||
              domain.length <= 20);
    });
    
    return personalEmails[0] || uniqueEmails[0];
  }

  return null;
});

// Enhanced phone extraction with multiple formats - specifically for Pakistani format
const extractPhoneFromFile = memoize((content) => {
  console.log("Debug - Phone extraction input preview:", content.substring(0, 300));
  
  // Handle line breaks in phone numbers (common in resumes)
  const processedContent = content
    .replace(/\n/g, ' ')
    .replace(/\r/g, ' ')
    .replace(/\s+/g, ' ');
  
  console.log("Debug - Processed content for phone extraction:", processedContent.substring(0, 300));
  
  // Enhanced patterns specifically for the Pakistani format: +92 318 0623294
  const phonePatterns = [
    // Exact Pakistani mobile format (priority)
    /\+92\s+\d{3}\s+\d{7}/g,                    // +92 318 0623294
    /\+92\s*\d{3}\s*\d{7}/g,                    // +923180623294 (compact)
    /\+92[-\s]\d{3}[-\s]\d{7}/g,               // +92-318-0623294
    /\+92\s*\d{3}[\s\-\.]?\d{7}/g,              // +92 3180623294 (no space)
    /\+92[\s\-]?\d{3}[\s\-]?\d{3}[\s\-]?\d{4}/g, // +92-318-062-3294
    /\+92\s\d{3}\s\d{7}/g,                    // +92 318 0623294
    
    // Other Pakistani formats
    /0\d{3}[\s\-]\d{3}[\s\-]\d{4}/g,          // 0318 0623294
    /\+92-\d{3}-\d{3}-\d{4}/g,                 // +92-318-062-3294
    /92\d{10}/g,                               // 923180623294
    
    // International with country code
    /\+\d{1,3}[\s\-\.\(]?\d{1,4}[\)\s\-\.]?\d{1,4}[\s\-\.]?\d{1,4}[\s\-\.]?\d{0,9}/g,
    
    // US format with parentheses
    /\(\d{3}\)[\s\-]?\d{3}[\s\-]?\d{4}/g,
    
    // Standard formats with various separators
    /\d{3}[\s\-\.]\d{3}[\s\-\.]\d{4}/g,
    /\d{3}\s\d{3}\s\d{4}/g,
    /\d{3}-\d{3}-\d{4}/g,
    /\d{3}\.\d{3}\.\d{4}/g,
    
    // Simple 10-15 digit sequences (last resort)
    /\b\d{10,15}\b/g
  ];

  const validPhones = [];
  
  // Search through processed content for phone numbers
  for (const pattern of phonePatterns) {
    const matches = [...processedContent.matchAll(pattern)];
    for (const match of matches) {
      const phoneNumber = match[0].trim();
      const digitsOnly = phoneNumber.replace(/[^0-9]/g, '');
      
      // Validate length
      if (digitsOnly.length >= 10 && digitsOnly.length <= 15) {
        // Check if this looks like a real phone number (not just digits in text)
        const context = processedContent.toLowerCase();
        const phoneContext = context.includes('tel') || 
                           context.includes('phone') ||
                           context.includes('mobile') ||
                           context.includes('cell') ||
                           context.includes('contact');
        
        validPhones.push({
          number: phoneNumber,
          digits: digitsOnly,
          contextScore: phoneContext ? 2 : 1,
          lengthScore: digitsOnly.length
        });
      }
    }
  }

  console.log("Debug - Phone matches found:", validPhones);
  
  // Sort by context relevance and return the best match
  if (validPhones.length > 0) {
    validPhones.sort((a, b) => {
      // Primary sort by context score, secondary by length (prefer longer more specific numbers)
      if (a.contextScore !== b.contextScore) {
        return b.contextScore - a.contextScore;
      }
      return b.lengthScore - a.lengthScore;
    });
      
    console.log("Debug - Best phone match:", validPhones[0].number);
    return validPhones[0].number;
  }

  return null;
});

// Enhanced location extraction
const extractLocationFromFile = memoize((content) => {
  const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0);

  // Define location patterns
  const patterns = [
    // City, State/Country patterns
    /([A-Z][a-z]+(?:\s[A-Z][a-z]+)*),\s*([A-Z]{2,}|[A-Z][a-z]+(?:\s[A-Z][a-z]+)*)/, // City, State/Country
    /([A-Z][a-z]+(?:\s[A-Z][a-z]+)*)\s*,\s*([A-Z]{2,})/, // City, ST
    /([A-Z][a-z]+(?:\s[A-Z][a-z]+)*)\s+([A-Z]{2,})/, // City ST
    // Postal code patterns
    /\b\d{5}(?:-\d{4})?\b/, // US Zip code
    /\b[A-Z][0-9][A-Z]\s?[0-9][A-Z][0-9]\b/i, // Canadian Postal Code
    /[A-Z]{1,2}\d[A-Z]?\s?\d[A-Z]{2}/i, // UK Postcode
    // Address patterns
    /\d+\s+[A-Z][a-z]+\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Place|Pl)/i,
  ];

  // Strategy 1: Scan the first few lines (usually contact info)
  for (let i = 0; i < Math.min(lines.length, 10); i++) {
    const line = lines[i];

    // Skip if it looks like a job title or company name
    if (/(Inc|Ltd|LLC|Corp|Company|LLP|Software|Developer|Engineer|Manager|Director|Analyst|Designer|Consultant)/i.test(line)) continue;

    // Check for location indicators
    if (line.toLowerCase().includes('location') || line.toLowerCase().includes('city') ||
      line.toLowerCase().includes('state') || line.toLowerCase().includes('country') ||
      line.toLowerCase().includes('reside') || line.toLowerCase().includes('based')) {
      // Extract location from this line
      for (const pattern of patterns) {
        const match = line.match(pattern);
        if (match) return match[0].trim();
      }
    }

    // Just look for location patterns
    for (const pattern of patterns) {
      const match = line.match(pattern);
      if (match) {
        // Validate that it's likely a location
        const matchedText = match[0].trim();

        // Skip if it looks like a date or other non-location text
        if (/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|\d{4})/.test(matchedText)) continue;

        // Skip if it's just a number that's not a postal code
        if (/^\d+$/.test(matchedText) && matchedText.length !== 5) continue;

        return matchedText;
      }
    }
  }

  // Strategy 2: Broader scan with more context awareness
  for (const line of lines.slice(0, 20)) {
    // Check if line contains contact-related keywords
    if (/(contact|email|phone|mobile|tel|fax|address|location|reside|live|based)/i.test(line.toLowerCase())) {
      // Look for location patterns in contact-related lines
      for (const pattern of patterns) {
        const match = line.match(pattern);
        if (match) return match[0].trim();
      }
    }
  }

  // Strategy 3: Look for common city names
  const commonCities = [
    'New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix', 'Philadelphia', 'San Antonio',
    'San Diego', 'Dallas', 'San Jose', 'London', 'Paris', 'Tokyo', 'Sydney', 'Toronto',
    'Vancouver', 'Berlin', 'Madrid', 'Rome', 'Amsterdam', 'Dubai', 'Singapore', 'Hong Kong',
    'Shanghai', 'Mumbai', 'SÃ£o Paulo', 'Mexico City', 'Moscow', 'Istanbul',
    'Pakistan', 'India', 'China', 'Japan', 'South Korea', 'Brazil', 'Russia', 'Canada', 'Australia',
    'Germany', 'France', 'Italy', 'Spain', 'United Kingdom', 'UK', 'USA', 'United States',
    'Bangladesh', 'Nigeria', 'Egypt', 'South Africa', 'Kenya', 'Ghana', 'Ethiopia', 'Morocco'
  ];

  for (const line of lines.slice(0, 15)) {
    for (const city of commonCities) {
      if (line.includes(city) && !/(Inc|Ltd|Company|Corp|Software|Developer|Engineer)/i.test(line)) {
        // If we find a city name, try to extract more context
        for (const pattern of patterns) {
          const match = line.match(pattern);
          if (match) return match[0].trim();
        }
        return city; // If no full pattern matches, return just the city
      }
    }
  }

  return null;
});

// Extract GitHub profile link
const extractGithubFromFile = memoize((content) => {
  // Comprehensive GitHub pattern matching all specified requirements
  const githubPatterns = [
    // Standard formats with various protocols
    /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)/gi,
    /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)\/?/gi,
    /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)\/.*$/gi,
    
    // Handle usernames with numbers, hyphens, underscores
    /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z][a-zA-Z0-9_-]*)/gi,
    
    // Handle trailing parameters and paths
    /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)(?:\?.*|\#.*|$)/gi
  ];
  
  // Try all patterns and return the first valid match
  for (const pattern of githubPatterns) {
    const match = pattern.exec(content);
    if (match && match[1]) {
      // Validate username format
      const username = match[1];
      if (username.length >= 1 && username.length <= 39 && 
          /^[a-zA-Z0-9][a-zA-Z0-9_-]*$/.test(username)) {
        return match[0].split('?')[0].split('#')[0]; // Remove query params and fragments
      }
    }
  }
  
  return null;
});

// Extract LinkedIn profile link
const extractLinkedinFromFile = memoize((content) => {
  // Comprehensive LinkedIn pattern matching all specified requirements
  const linkedinPatterns = [
    // Standard profile paths
    /(?:https?:\/\/)?(?:www\.)?linkedin\.com\/in\/([a-zA-Z0-9_-]+)/gi,
    /(?:https?:\/\/)?(?:www\.)?linkedin\.com\/pub\/([a-zA-Z0-9_-]+)/gi,
    
    // Handle various username formats including encoded characters
    /(?:https?:\/\/)?(?:www\.)?linkedin\.com\/in\/([a-zA-Z][a-zA-Z0-9_-]*)/gi,
    /(?:https?:\/\/)?(?:www\.)?linkedin\.com\/pub\/([a-zA-Z][a-zA-Z0-9_-]*)/gi,
    
    // Handle special paths and encoded usernames
    /(?:https?:\/\/)?(?:www\.)?linkedin\.com\/in\/([a-zA-Z0-9][a-zA-Z0-9_-]*[a-zA-Z0-9])/gi,
    /(?:https?:\/\/)?(?:www\.)?linkedin\.com\/pub\/([a-zA-Z0-9][a-zA-Z0-9_-]*[a-zA-Z0-9])/gi,
    
    // Handle trailing slashes and additional path parameters
    /(?:https?:\/\/)?(?:www\.)?linkedin\.com\/(?:in|pub)\/([a-zA-Z0-9_-]+)\/?/gi,
    /(?:https?:\/\/)?(?:www\.)?linkedin\.com\/(?:in|pub)\/([a-zA-Z0-9_-]+)(?:\?.*|\#.*|$)/gi
  ];
  
  // Try all patterns and return the first valid match
  for (const pattern of linkedinPatterns) {
    const match = pattern.exec(content);
    if (match && match[1]) {
      // Validate username format
      const username = match[1];
      if (username.length >= 1 && username.length <= 100 && 
          /^[a-zA-Z0-9][a-zA-Z0-9_-]*$/.test(username)) {
        return match[0].split('?')[0].split('#')[0]; // Remove query params and fragments
      }
    }
  }
  
  return null;
});

const extractExperienceFromFile = memoize((content) => {
  console.log("Debug - Experience extraction input preview:", content.substring(0, 300));
  
  // Enhanced experience extraction with better section detection - more precise boundaries
  const experienceSectionMatch = content.match(/(?:EXPERIENCE|WORK EXPERIENCE|PROFESSIONAL EXPERIENCE|EMPLOYMENT HISTORY)[\s\S]*?(?=\n\s*(?:EDUCATION|ACADEMIC|SKILLS|TECHNICAL SKILLS|CERTIFICATES?|AWARDS?|PROJECTS|LANGUAGES|INTERESTS?|OBJECTIVE|SUMMARY|CONTACT|NAME)\s*\n|$)/i);
  
  console.log("Debug - Experience section match:", experienceSectionMatch ? "Found" : "Not found");
  
  if (!experienceSectionMatch) {
    console.log("Debug - No experience section found, returning empty array");
    return [];
  }

  const experienceText = experienceSectionMatch[0];
  console.log("Debug - Experience text preview:", experienceText.substring(0, 200));
  const entries = [];
  const lines = experienceText.split('\n').map(l => l.trim()).filter(l => l.length > 5);

  // Define comprehensive job title keywords to help identify positions
  const jobTitleKeywords = [
    'developer', 'engineer', 'manager', 'director', 'analyst', 'specialist', 
    'consultant', 'architect', 'lead', 'senior', 'junior', 'intern', 'coordinator',
    'associate', 'executive', 'officer', 'president', 'vp', 'cto', 'ceo', 'founder',
    'designer', 'technician', 'operator', 'administrator', 'supervisor', 'advisor',
    'consultant', 'specialist', 'planner', 'strategist', 'analyst', 'researcher',
    'programmer', 'coder', 'data', 'scientist', 'database', 'network', 'security',
    'quality', 'assurance', 'tester', 'support', 'helpdesk', 'customer', 'service'
  ];

  // Patterns for dates and durations
  const datePattern = /(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December|Q\d)?\s*\d{4}/i;

  // First, try to find entries with dates
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Look for lines that contain dates (indicating experience entries)
    if (datePattern.test(line)) {
      const entry = {
        company: null,
        position: null,
        duration: line.match(/(?:\d{4}|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|Present|Current|to\s*\w+)\s*[-\u2013\u2014\s]+(?:\d{4}|Present|Current)/gi)?.[0] || 'Duration specified',
        responsibilities: []
      };

      // Look for company and position in the current line and surrounding lines
      const searchContext = [];
      if (lines[i - 1]) searchContext.push(lines[i - 1]);
      searchContext.push(line);
      if (lines[i + 1]) searchContext.push(lines[i + 1]);

      for (const ctx of searchContext) {
        // Look for 'at' pattern (e.g., 'Software Engineer at Google')
        const atPattern = /^(.*?)\s+at\s+(.+)$/i;
        const atMatch = ctx.match(atPattern);
        if (atMatch) {
          entry.position = atMatch[1].trim();
          entry.company = atMatch[2].trim();
          break;
        }

        // Look for '|' pattern (e.g., 'Google | Software Engineer')
        const pipePattern = /^(.*?)\s*[|\-]\s*(.+)$/;
        const pipeMatch = ctx.match(pipePattern);
        if (pipeMatch) {
          const part1 = pipeMatch[1].trim();
          const part2 = pipeMatch[2].trim();

          // Determine which is company and which is position based on keywords
          const part1Lower = part1.toLowerCase();
          const part2Lower = part2.toLowerCase();

          if (jobTitleKeywords.some(keyword => part1Lower.includes(keyword))) {
            entry.position = part1;
            entry.company = part2;
          } else if (jobTitleKeywords.some(keyword => part2Lower.includes(keyword))) {
            entry.position = part2;
            entry.company = part1;
          } else {
            // Default: assume first part is company
            entry.company = part1;
            entry.position = part2;
          }
          break;
        }

        // If we find a company name pattern
        if (!entry.company && ctx.length < 100) {
          // Look for company-like names (avoiding obvious job titles)
          if (!jobTitleKeywords.some(keyword => ctx.toLowerCase().includes(keyword)) &&
            (ctx.includes('Inc') || ctx.includes('LLC') || ctx.includes('Corp') || ctx.includes('Ltd') ||
              ctx.length < 50 && !datePattern.test(ctx))) {
            entry.company = ctx;
          }
        }
      }

      // If we still don't have a position, try to infer from nearby text
      if (!entry.position) {
        // Look for job titles in nearby lines
        for (let j = Math.max(0, i - 2); j <= Math.min(lines.length - 1, i + 2); j++) {
          if (j !== i) {
            const nearbyLine = lines[j];
            if (jobTitleKeywords.some(keyword => nearbyLine.toLowerCase().includes(keyword))) {
              entry.position = nearbyLine;
              break;
            }
          }
        }
      }

      // Add responsibilities from following lines
      for (let j = i + 1; j < lines.length && j < i + 10; j++) {
        const nextLine = lines[j];

        // Stop if we encounter another date (next experience entry)
        if (datePattern.test(nextLine)) break;

        // Stop if we encounter a new section
        if (/^(EDUCATION|SKILLS|CERTIFICATES?|AWARDS?|PROJECTS|LANGUAGES|INTERESTS?)/i.test(nextLine)) break;

        // Add to responsibilities if it looks like a bullet point or description
        if (nextLine.startsWith('-') || nextLine.startsWith('*') || nextLine.startsWith('â€¢') ||
          nextLine.length > 10 && !datePattern.test(nextLine)) {
          entry.responsibilities.push(nextLine);
        }
      }

      // Only add if we have meaningful data
      if (entry.company || entry.position) {
        entries.push({
          company: entry.company || 'Company Not Specified',
          position: entry.position || 'Position Not Specified',
          duration: entry.duration,
          responsibilities: entry.responsibilities
        });
      }
    }
  }

  // If no entries found with dates, try to find entries based on job title patterns
  if (entries.length === 0) {
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Look for lines that contain job titles
      if (jobTitleKeywords.some(keyword => line.toLowerCase().includes(keyword)) ||
        line.toLowerCase().includes('engineer') || line.toLowerCase().includes('developer')) {
        const entry = {
          company: null,
          position: null,
          duration: 'Duration not specified',
          responsibilities: []
        };

        // Extract position from the line
        entry.position = line;

        // Look for company nearby
        for (let j = Math.max(0, i - 2); j <= Math.min(lines.length - 1, i + 2); j++) {
          if (j !== i) {
            const nearbyLine = lines[j];
            // Look for company-like patterns
            if (nearbyLine.includes('Inc') || nearbyLine.includes('LLC') ||
              nearbyLine.includes('Corp') || nearbyLine.includes('Ltd') ||
              nearbyLine.includes('Company') || nearbyLine.includes('Organization')) {
              entry.company = nearbyLine;
              break;
            }
          }
        }

        // Add responsibilities from following lines
        for (let j = i + 1; j < lines.length && j < i + 10; j++) {
          const nextLine = lines[j];

          // Stop if we encounter a new section
          if (/^(EDUCATION|SKILLS|CERTIFICATES?|AWARDS?|PROJECTS|LANGUAGES|INTERESTS?)/i.test(nextLine)) break;

          // Add to responsibilities if it looks like a bullet point or description
          if (nextLine.startsWith('-') || nextLine.startsWith('*') || nextLine.startsWith('â€¢') ||
            nextLine.length > 10) {
            entry.responsibilities.push(nextLine);
          }
        }

        // Only add if we have meaningful data
        if (entry.position) {
          entries.push({
            company: entry.company || 'Company Not Specified',
            position: entry.position,
            duration: entry.duration,
            responsibilities: entry.responsibilities
          });
        }
      }
    }
  }

  return entries.length > 0 ? entries.slice(0, 10) : [];
});



// Helper function to extract company from context
const extractCompanyFromContext = (content, index) => {
  const contextStart = Math.max(0, index - 200);
  const contextEnd = Math.min(content.length, index + 200);
  const context = content.substring(contextStart, contextEnd);
  
  // Look for company-related patterns near the match
  const companyPatterns = [
    /(?:at|@|worked at|employed at|position at)\s+([A-Z][A-Za-z\s\d\-\.&\(\)]+)/gi,
    /([A-Z][A-Za-z\s\d\-\.&\(\)]+)\s+(?:Inc|LLC|Corporation|Corp|Ltd|Limited|Company|Co|Group|Holdings|Enterprises|Industries|Technologies|Systems|Solutions|Services|Partners|Associates|Foundation|Institute|University|College|School|Hospital|Medical Center|Clinic|Healthcare|Bank|Financial|Insurance|Consulting|Development|Software|Media|Entertainment|Design|Marketing|Advertising|Agency|Studio|Shop|Store|Restaurant|Hotel|Resort|Travel|Tourism|Airlines|Aerospace|Automotive|Energy|Utilities|Telecommunications|Retail|Manufacturing|Pharmaceutical|Biotech|Research|Laboratory|Government|Military|NGO|Non-profit|Charity|Organization|Department|Division|Branch|Facility|Plant|Factory|Warehouse|Distribution Center)/gi
  ];
  
  for (const pattern of companyPatterns) {
    const matches = [...context.matchAll(pattern)];
    if (matches.length > 0) {
      return matches[0][1] || matches[0][0];
    }
  }
  
  // Fallback to nearby capitalized phrases
  const nearbyText = content.substring(index - 50, index + 50);
  const capitalizedWords = nearbyText.match(/([A-Z][A-Za-z\s]{5,40})/g);
  if (capitalizedWords && capitalizedWords.length > 0) {
    return capitalizedWords[0].trim();
  }
  
  return 'Company Not Found';
};

// Helper function to extract duration from context
const extractDurationFromContext = (content, index) => {
  const contextStart = Math.max(0, index - 100);
  const contextEnd = Math.min(content.length, index + 100);
  const context = content.substring(contextStart, contextEnd);
  
  // Look for date patterns near the match
  const datePatterns = [
    /\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}\s*[-\u2013\u2014]\s*(?:Present|Current|\d{4})/gi,
    /\b\d{4}\s*[-\u2013\u2014]\s*(?:Present|Current|\d{4})\b/gi,
    /\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}\b/gi,
    /\b\d{4}\b/gi
  ];
  
  for (const pattern of datePatterns) {
    const matches = [...context.matchAll(pattern)];
    if (matches.length > 0) {
      return matches[0][0];
    }
  }
  
  return 'Duration Not Found';
};

// Extract skills
const extractTechnicalSkillsFromFile = memoize((content) => {
  console.log("Debug - Technical skills extraction input preview:", content.substring(0, 500));
  
  // Look for skills sections with various headings
  const skillsSections = [
    'SKILLS', 'TECHNICAL SKILLS', 'TECHNICAL COMPETENCIES', 'TECHNICAL PROFICIENCIES',
    'PROGRAMMING LANGUAGES', 'DEVELOPMENT TOOLS', 'FRAMEWORKS', 'SOFTWARE', 'TOOLS'
  ];
  
  let skillsContent = '';
  
  // Try to find skills section
  for (const section of skillsSections) {
    const pattern = new RegExp(`(${section})[\s\S]*?(?=EXPERIENCE|EDUCATION|CERTIFICATES?|PROJECTS|LANGUAGES|INTERESTS?|WORK|$)`, 'i');
    const match = content.match(pattern);
    if (match) {
      skillsContent = match[0];
      break;
    }
  }
  
  // If no section found, use the entire content
  if (!skillsContent) {
    skillsContent = content;
  }

  const skills = new Set();

  // Multiple extraction patterns
  const patterns = [
    /:\s*([A-Za-z0-9\s,\-&.\/+]+)(?=\n|[.;]|$)/gi,     // Skills after colon
    /-\s*([A-Za-z0-9\s,\-&.\/+]+)(?=\n|$)/g,             // Skills after dash
    /\*\s*([A-Za-z0-9\s,\-&.\/+]+)(?=\n|$)/g,            // Skills after asterisk
    /â€¢\s*([A-Za-z0-9\s,\-&.\/+]+)(?=\n|$)/g,             // Skills after bullet
    /\u27A4\s*([A-Za-z0-9\s,\-&.\/+]+)(?=\n|$)/g,         // Skills after arrow bullet
    /^\s*([A-Za-z0-9][A-Za-z0-9\s,&\-]+)(?=:|$)/gm,     // Lines starting with skills
  ];

  // Process each pattern
  for (const pattern of patterns) {
    let match;
    const regex = new RegExp(pattern);
    while ((match = regex.exec(skillsContent)) !== null) {
      let skillList = match[1].trim();
      
      // Remove trailing punctuation and spaces
      skillList = skillList.replace(/[.,;:\/]\s*$/, '');
      
      // Split skills based on various delimiters
      let skillsToProcess = [];
      
      if (skillList.includes('|') && skillList.length > 100) {
        // This looks like it was split poorly, extract individual tokens
        const individualKeywords = skillList.split(/\s+/);
        skillsToProcess = individualKeywords.filter(token => 
          token.length > 2 && 
          !/^(and|or|the|for|in|of|to|with|by|from|on|at|as|is|it|an|a|are|be|been|have|has|had|do|does|did|will|would|could|should|may|might|must|can|shall)$/i.test(token)
        );
      } else {
        // Split by common delimiters
        skillsToProcess = skillList.split(/[;,\/]|\s+(?:and|&|\+|plus)\s+/i);
      }
      
      skillsToProcess.forEach(skill => {
        const cleanSkill = skill.trim().replace(/[.]+$/, '');
        if (cleanSkill && cleanSkill.length > 1 && cleanSkill.length < 50) {
          // Additional validation to avoid false positives
          if (!/^(\d+|[A-Z]{2,}|[a-z]{2,})$/.test(cleanSkill) && 
              !/^(experience|knowledge|skills?|proficient|familiar|expert|advanced|intermediate|basic)$/i.test(cleanSkill)) {
            skills.add(cleanSkill);
          }
        }
      });
    }
  }

  // Also look for common technical skills directly in the content
  const commonTechSkills = [
    // Programming Languages
    'JavaScript', 'TypeScript', 'Python', 'Java', 'C#', 'C++', 'Go', 'Rust', 'PHP', 'Ruby', 'Swift', 'Kotlin', 'Scala', 'C', 'R', 'MATLAB',
    // Frontend Frameworks/Libraries
    'React', 'Vue.js', 'Angular', 'Svelte', 'Next.js', 'Gatsby', 'Nuxt.js', 'jQuery', 'Bootstrap', 'Tailwind', 'Material UI', 'Ant Design', 'Sass', 'Less',
    // Backend Technologies
    'Node.js', 'Express', 'Django', 'Flask', 'Spring Boot', 'Laravel', 'Rails', 'FastAPI', 'ASP.NET', 'NestJS',
    // Databases
    'PostgreSQL', 'MySQL', 'MongoDB', 'Redis', 'Elasticsearch', 'Oracle', 'SQLite', 'Firebase', 'Cassandra', 'DynamoDB',
    // Cloud Platforms
    'AWS', 'Azure', 'GCP', 'Heroku', 'Netlify', 'Vercel', 'DigitalOcean', 'Linode',
    // DevOps Tools
    'Docker', 'Kubernetes', 'Jenkins', 'Terraform', 'Ansible', 'GitLab CI', 'GitHub Actions', 'CircleCI', 'Travis CI',
    // Version Control & Collaboration
    'Git', 'GitHub', 'GitLab', 'Bitbucket', 'Jira', 'Confluence', 'Slack', 'Trello',
    // Methodologies
    'Agile', 'Scrum', 'Kanban', 'TDD', 'BDD', 'CI/CD', 'DevOps', 'Waterfall',
    // Other Technologies
    'Linux', 'Bash', 'PowerShell', 'GraphQL', 'REST', 'SOAP', 'JUnit', 'Selenium', 'Kafka', 'RabbitMQ', 'Nginx', 'Apache'
  ];

  // Check for presence of common skills in the content
  commonTechSkills.forEach(skill => {
    const escapedSkill = skill.replace(/[.*+?^${}()|\[\]\\]/g, '\$&');
    const skillRegex = new RegExp('\\b' + escapedSkill + '\\b', 'gi');
    if (skillRegex.test(content)) {
      skills.add(skill);
    }
  });

  const finalSkills = Array.from(skills).filter(skill => {
    // Remove skills that are too generic or part of other words
    return !/\b(experience|knowledge|skills?|proficient|familiar|expert|advanced|intermediate|basic|working|strong|good|solid)\b/i.test(skill) &&
           !/^\d+$/.test(skill) &&
           skill.length > 1;
  });

  console.log("Debug - Technical skills found:", finalSkills);
  return finalSkills;
});

const extractEducationSkillsFromFile = memoize((content) => {
  console.log("=== EDUCATION SKILLS EXTRACTION ===");
  
  const educationSkills = [
    'Curriculum Development', 'Classroom Management', 'Student Assessment',
    'Lesson Planning', 'Differentiated Instruction', 'Educational Technology',
    'Individualized Education Programs', 'Behavior Management', 'Parent Communication',
    'Grade Level Team Collaboration', 'Subject Matter Expertise', 'Test Preparation',
    'Special Education', 'ESL Education', 'Gifted Education', 'Literacy Instruction',
    'Mathematics Instruction', 'Science Education', 'Social Studies Education',
    'Learning Management Systems', 'Educational Software', 'Online Teaching',
    'Digital Assessment Tools', 'Interactive Whiteboards', 'Video Conferencing',
    'Educational Apps', 'Multimedia Presentations', 'Virtual Classroom Management',
    'Distance Learning', 'Blended Learning', 'Flipped Classroom', 'Gamification',
    'Educational Data Analytics', 'Portfolio Assessment', 'Rubric Development',
    'Academic Program Development', 'Faculty Training', 'School Administration',
    'Educational Leadership', 'Budget Management', 'Policy Development',
    'Accreditation Processes', 'Curriculum Standards', 'Educational Assessment',
    'Teacher Evaluation', 'Staff Development', 'Parent Engagement',
    'Community Outreach', 'Grant Writing', 'Research Methodology',
    'Patience', 'Communication', 'Leadership', 'Mentoring', 'Adaptability', 'Organizational Skills'
  ];
  
  const foundSkills = [];
  const processedContent = content.toLowerCase();
  
  // Use cached regex for better performance
  educationSkills.forEach(skill => {
    const escapedSkill = escapeRegExp(skill.toLowerCase());
    const regex = getCachedRegex(`\b${escapedSkill}\b`, 'gi');
    if (regex.test(content) && !foundSkills.includes(skill)) {
      foundSkills.push(skill);
    }
  });
  
  return foundSkills;
});



const extractEducationResponsibilities = (content, index) => {
  // Extract responsibilities from education context
  const relevantText = content.substring(Math.max(0, index - 200), Math.min(content.length, index + 500));
  const responsibilities = [];
  
  const educationTerms = [
    'classroom instruction', 'lesson planning', 'student assessment', 'grade reporting',
    'parent communication', 'student discipline', 'curriculum development',
    'professional development', 'committee participation', 'extracurricular supervision',
    'individualized education', 'special needs support', 'behavioral interventions',
    'student mentoring', 'academic counseling', 'educational technology',
    'standardized testing', 'data analysis', 'collaborative planning'
  ];
  
  educationTerms.forEach(term => {
    const escapedTerm = escapeRegExp(term);
    const regex = new RegExp(`\\b${escapedTerm}\\b`, 'gi');
    if (regex.test(relevantText)) {
      responsibilities.push(term.charAt(0).toUpperCase() + term.slice(1));
    }
  });
  
  return responsibilities;
};

const extractBusinessSkillsFromFile = memoize((content) => {
  console.log("=== BUSINESS SKILLS EXTRACTION ===");
  
  const businessSkills = [
    'Strategic Planning', 'Team Leadership', 'Budget Management', 'Financial Analysis',
    'Project Management', 'Change Management', 'Process Improvement', 'Stakeholder Management',
    'Performance Management', 'Risk Management', 'Quality Management', 'Supply Chain Management',
    'Operations Management', 'Human Resources', 'Organizational Development', 'Business Development',
    'Client Relationship Management', 'Vendor Management', 'Contract Negotiation',
    'Financial Modeling', 'Data Analysis', 'Market Research', 'Competitive Analysis',
    'Business Intelligence', 'Statistical Analysis', 'Forecasting', 'ROI Analysis',
    'Cost Analysis', 'Pricing Strategy', 'Revenue Optimization', 'Performance Metrics',
    'KPI Development', 'Business Process Mapping', 'SWOT Analysis', 'Trend Analysis',
    'Predictive Analytics', 'Dashboards', 'Reporting',
    'Process Optimization', 'Lean Six Sigma', 'Continuous Improvement', 'Workflow Design',
    'Quality Assurance', 'Compliance', 'Regulatory Affairs', 'Audit Preparation',
    'Documentation', 'Standard Operating Procedures', 'Training Programs', 'Performance Audits',
    'Inventory Management', 'Logistics', 'Procurement', 'Vendor Relations', 'Customer Service',
    'Leadership', 'Communication', 'Negotiation', 'Problem Solving', 'Teamwork', 'Decision Making'
  ];
  
  const foundSkills = [];
  
  // Use cached regex for better performance
  businessSkills.forEach(skill => {
    const escapedSkill = escapeRegExp(skill.toLowerCase());
    const regex = getCachedRegex(`\b${escapedSkill}\b`, 'gi');
    if (regex.test(content) && !foundSkills.includes(skill)) {
      foundSkills.push(skill);
    }
  });
  
  return foundSkills;
});



const extractBusinessResponsibilities = (content, index) => {
  // Extract responsibilities from business context
  const relevantText = content.substring(Math.max(0, index - 200), Math.min(content.length, index + 500));
  const responsibilities = [];
  
  const businessTerms = [
    'strategic planning', 'budget management', 'financial analysis', 'reporting',
    'team leadership', 'staff management', 'performance management', 'process improvement',
    'stakeholder engagement', 'client relations', 'vendor management', 'contract negotiation',
    'risk assessment', 'compliance monitoring', 'quality assurance', 'project oversight',
    'change management', 'organizational development', 'policy implementation',
    'regulatory compliance', 'audit preparation', 'business development', 'market analysis',
    'competitive intelligence', 'business intelligence', 'data analysis', 'performance metrics',
    'dashboard creation', 'forecasting', 'planning', 'execution'
  ];
  
  businessTerms.forEach(term => {
    const escapedTerm = escapeRegExp(term);
    const regex = new RegExp(`\\b${escapedTerm}\\b`, 'gi');
    if (regex.test(relevantText)) {
      responsibilities.push(term.charAt(0).toUpperCase() + term.slice(1));
    }
  });
  
  return responsibilities;
};

const extractSoftSkillsFromFile = memoize((content) => {
  console.log("Debug - Soft skills extraction input preview:", content.substring(0, 500));
  
  const commonSoftSkills = [
    'Communication', 'Leadership', 'Teamwork', 'Problem Solving', 'Critical Thinking',
    'Time Management', 'Adaptability', 'Creativity', 'Collaboration', 'Interpersonal Skills',
    'Emotional Intelligence', 'Decision Making', 'Conflict Resolution', 'Negotiation',
    'Project Management', 'Organization', 'Attention to Detail', 'Multitasking',
    'Customer Service', 'Presentation Skills', 'Public Speaking', 'Writing Skills',
    'Analytical Skills', 'Research Skills', 'Planning', 'Strategic Thinking',
    'Innovation', 'Flexibility', 'Resilience', 'Work Ethic', 'Reliability',
    'Initiative', 'Self-Motivation', 'Learning Agility', 'Cultural Awareness'
  ];

  const foundSoftSkills = [];
  
  commonSoftSkills.forEach(skill => {
    const escapedSkill = skill.replace(/[.*+?^${}()|\[\]\\]/g, '\$&');
    const skillRegex = new RegExp('\b' + escapedSkill + '\b', 'gi');
    if (skillRegex.test(content)) {
      foundSoftSkills.push(skill);
    }
  });

  console.log("Debug - Soft skills found:", foundSoftSkills);
  return foundSoftSkills;
});





// Extract certifications
const extractCertificationsFromFile = memoize((content) => {
  const certsSectionMatch = content.match(/(CERTIFICATES?|CERTIFICATIONS?|LICENSES?)[\s\S]*?(?=EXPERIENCE|EDUCATION|SKILLS|PROJECTS|$)/i);

  if (!certsSectionMatch) {
    // Return default if no certifications section found
    return [];
  }

  const certsText = certsSectionMatch[0];

  // Extract certifications
  const certifications = [];
  const certPattern = /([A-Za-z\s\-&]+)(?:\s+\||-|\s)\s+([A-Za-z\s\-&]+)(?:\s+\||-|\s)\s+([A-Za-z\s0-9,\/\-]+)/g; // eslint-disable-line no-useless-escape
  let match;

  while ((match = certPattern.exec(certsText)) !== null) {
    certifications.push({
      name: match[1]?.trim(),
      issuer: match[2]?.trim(),
      date: match[3]?.trim()
    });
  }

  return certifications;
});

// Extract summary/objective
const extractSummaryFromFile = memoize((content) => {
  const summarySectionMatch = content.match(/(SUMMARY|OBJECTIVE|PROFESSIONAL SUMMARY|CAREER SUMMARY)[\s\S]*?(?=EXPERIENCE|EDUCATION|SKILLS|CERTIFICATES|PROJECTS|$)/i);

  if (!summarySectionMatch) {
    // Return default if no summary section found
    return '';
  }

  const summaryText = summarySectionMatch[0];

  // Clean up the summary text
  const cleanedSummary = summaryText.replace(/(SUMMARY|OBJECTIVE|PROFESSIONAL SUMMARY|CAREER SUMMARY)\s*/i, '').trim();

  return cleanedSummary;
});

// Extract projects
const extractProjectsFromFile = memoize((content) => {
  const projectsSectionMatch = content.match(/(PROJECTS|KEY PROJECTS|RELEVANT PROJECTS)[\s\S]*?(?=EXPERIENCE|EDUCATION|SKILLS|CERTIFICATES|SUMMARY|$)/i);

  if (!projectsSectionMatch) {
    // Return default if no projects section found
    return [];
  }

  const projectsText = projectsSectionMatch[0];

  // Extract projects
  const projects = [];

  // Pattern for projects
  const projectPattern = /([A-Za-z\s\-&]+)\s*[:\-]\s*([A-Za-z\s\-&\.,!?\(\)]+)/g; // eslint-disable-line no-useless-escape
  let match;

  while ((match = projectPattern.exec(projectsText)) !== null) {
    projects.push({
      name: match[1]?.trim(),
      description: match[2]?.trim()
    });
  }

  return projects;
});

// Extract languages
const extractLanguagesFromFile = memoize((content) => {
  const languagesSectionMatch = content.match(/(LANGUAGES?|SPOKEN LANGUAGES?|LANGUAGE PROFICIENCY)[\s\S]*?(?=EXPERIENCE|EDUCATION|SKILLS|CERTIFICATES|PROJECTS|SUMMARY|$)/i);

  if (!languagesSectionMatch) {
    // Return default if no languages section found
    return [];
  }

  const languagesText = languagesSectionMatch[0];

  // Extract languages
  const languages = [];

  // Pattern for languages
  const langPattern = /([A-Za-z\s]+):?\s*([A-Za-z\s]+)/g;
  let match;

  while ((match = langPattern.exec(languagesText)) !== null) {
    languages.push({
      language: match[1].trim(),
      proficiency: match[2].trim()
    });
  }

  return languages;
});

// Extract interests
const extractInterestsFromFile = memoize((content) => {
  const interestsSectionMatch = content.match(/(INTERESTS?|HOBBIES?|ACTIVITIES?)[\s\S]*?(?=EXPERIENCE|EDUCATION|SKILLS|CERTIFICATES|PROJECTS|SUMMARY|$)/i);

  if (!interestsSectionMatch) {
    // Return default if no interests section found
    return [];
  }

  const interestsText = interestsSectionMatch[0];

  // Extract interests
  const interests = [];

  // Pattern for interests (split by comma, semicolon, or 'and')
  const interestPattern = /([A-Za-z\s\-&\.,!?]+)/g; // eslint-disable-line no-useless-escape
  let match;

  while ((match = interestPattern.exec(interestsText)) !== null) {
    const interest = match[1].trim();
    if (interest && !interest.toLowerCase().includes('interests') && !interest.toLowerCase().includes('hobbies') && interest.length > 2) {
      interests.push(interest);
    }
  }

  return interests;
});

// Using imported validation functions from validationService
// calculateCompletenessScore and calculateConfidenceScores are imported at the top

// Using imported validateExtractedData function from validationService



const analyzeResume = async (resumeData) => {
  // Use centralized AI service which handles backend preference and direct fallbacks
  try {
    const analysis = await analyzeResumeWithAI(resumeData);
    if (analysis) return analysis;
  } catch (error) {
    console.error("AI Analysis failed, falling back to simulation:", error);
  }

  // Fallback to simulation if AI fails
  return new Promise((resolve) => {
    setTimeout(() => {
      // Advanced analysis results with industry-specific recommendations
      const analysis = {
        overallScore: calculateOverallScore(resumeData),
        scores: {
          ats: Math.min(Math.floor(resumeData.extractedData.experience.length * 6), 30),
          keyword: Math.min(Math.floor(resumeData.extractedData.skills.technical.length * 2), 30),
          content: Math.min(Math.floor(resumeData.extractedData.experience.filter(exp => exp.responsibilities.length > 0).length * 4 + 8), 20),
          relevance: Math.min(Math.floor(resumeData.extractedData.skills.technical.length * 1.5), 20)
        },
        strengths: [
          "Strong technical skills in JavaScript, React, and Node.js",
          "Good work experience with progressive responsibilities",
          "Clear chronological work history showing growth",
          "Relevant projects that demonstrate practical skills",
          "Additional certifications that enhance credibility"
        ],
        weaknesses: [
          "Summary section could be more compelling and specific",
          "Missing quantifiable achievements in work experience",
          "Education section is basic without honors or additional certifications",
          "Could benefit from more diverse technology stack examples"
        ],
        suggestions: generateSuggestions(resumeData),
        industrySpecific: {
          recommendations: [
            "Highlight experience with version control systems like Git in your summary",
            "Emphasize experience with testing frameworks relevant to the role",
            "Include metrics that show impact of your contributions"
          ],
          trendingKeywords: [
            'DevOps', 'Microservices', 'Cloud Computing', 'Agile', 'Scrum',
            'Continuous Integration', 'Continuous Deployment', 'API Development'
          ]
        },
        keywordMatches: {
          matched: ['JavaScript', 'React', 'Node.js', 'Python', 'SQL', 'AWS', 'Docker', 'Git'],
          missing: ['TypeScript', 'GraphQL', 'Kubernetes', 'Jest', 'CI/CD', 'Microservices', 'RESTful APIs']
        },
        personalization: {
          targetRoleFit: 'good',
          careerGoalsAlignment: 'medium',
          customFeedback: generateCustomFeedback(resumeData)
        }
      };

      resolve(analysis);
    }, 2500);
  });
};

// Calculate overall score based on multiple factors
const calculateOverallScore = (resumeData) => {
  // Base score calculation - starting from 0 and building up
  let score = 0;

  // Experience score (0-25)
  const experienceCount = resumeData?.extractedData?.experience?.length || 0;
  const experienceScore = Math.min(experienceCount * 8, 25);

  // Skills score (0-25) - weighted based on diversity and relevance
  const technicalSkillsCount = resumeData?.extractedData?.skills?.technical?.length || 0;
  const softSkillsCount = resumeData?.extractedData?.skills?.soft?.length || 0;
  const skillsScore = Math.min((technicalSkillsCount * 1.5) + (softSkillsCount * 0.8), 25);

  // Education score (0-15) - weighted based on degree level
  const educationCount = resumeData?.extractedData?.education?.length || 0;
  const educationScore = educationCount > 0 ? 10 : 0;

  // Certifications score (0-15) - more weight per certification
  const certificationsCount = resumeData?.extractedData?.certifications?.length || 0;
  const certificationsScore = Math.min(certificationsCount * 4, 15);

  // Projects score (0-10) - weighted based on quality indicators
  const projectsCount = resumeData?.extractedData?.projects?.length || 0;
  const projectsScore = Math.min(projectsCount * 2.5, 10);

  // Summary score (0-10) - based on length and content quality
  const summaryText = resumeData?.extractedData?.summary || '';
  const summaryLength = summaryText.trim().length;
  const summaryScore = summaryLength > 0 ? Math.min(summaryLength / 10, 10) : 0; // Up to 100 chars gets full score

  // Quality factors bonus
  let qualityBonus = 0;

  // Check for quantifiable achievements in experience
  const experiences = resumeData?.extractedData?.experience || [];
  const hasQuantifiedAchievements = experiences.some(exp =>
    exp.responsibilities?.some(resp =>
      /\d+%|\d+\s*(users|customers|dollars|budget|team|projects)/i.test(resp)
    )
  );

  if (hasQuantifiedAchievements) {
    qualityBonus += 5;
  }

  // Check for action verbs in experience descriptions
  const actionVerbs = ['developed', 'managed', 'created', 'designed', 'implemented', 'optimized', 'led', 'delivered'];
  const hasActionVerbs = experiences.some(exp =>
    exp.responsibilities?.some(resp =>
      actionVerbs.some(verb => resp.toLowerCase().includes(verb))
    )
  );

  if (hasActionVerbs) {
    qualityBonus += 3;
  }

  score = experienceScore + skillsScore + educationScore + certificationsScore + projectsScore + summaryScore + qualityBonus;

  // Apply reasonable upper limit
  return Math.max(5, Math.min(score, 100)); // Ensure at least 5% if some data exists, cap at 100
};



// Generate personalized suggestions
const generateSuggestions = (resumeData) => {
  const suggestions = [];

  // Check for missing quantified achievements
  const experiences = resumeData?.extractedData?.experience || [];
  const hasQuantifiedAchievements = experiences.some(exp =>
    exp.responsibilities?.some(resp =>
      /\d+%|\d+\s*(users|customers|dollars|budget|team|projects|improved|reduced|increased|generated)/i.test(resp)
    )
  );

  if (!hasQuantifiedAchievements) {
    suggestions.push("Add specific metrics to quantify your achievements (e.g., 'increased efficiency by 30%', 'managed team of 5 developers', 'reduced costs by 20%')");
  }

  // Check for certifications
  const certificationsCount = resumeData?.extractedData?.certifications?.length || 0;
  if (certificationsCount === 0) {
    suggestions.push("Include relevant certifications or online courses to show continuous learning");
  }

  // Check for summary
  const hasSummary = !!(resumeData?.extractedData?.summary && resumeData.extractedData.summary.trim().length > 0);
  if (!hasSummary) {
    suggestions.push("Add a compelling summary section that highlights your key qualifications and career objectives");
  } else {
    const summaryLength = resumeData?.extractedData?.summary?.trim().length || 0;
    if (summaryLength < 50) {
      suggestions.push("Expand your summary section to better showcase your qualifications and experience");
    }
  }

  // Check for action verbs
  const actionVerbs = ['developed', 'managed', 'created', 'designed', 'implemented', 'optimized', 'led', 'delivered', 'built', 'architected'];
  const hasActionVerbs = experiences.some(exp =>
    exp.responsibilities?.some(resp =>
      actionVerbs.some(verb => resp.toLowerCase().includes(verb))
    )
  );

  if (!hasActionVerbs) {
    suggestions.push("Use action verbs like 'developed', 'managed', 'created', 'designed', 'implemented' to describe your achievements");
  }

  // Check for specific technical skills
  const technicalSkills = resumeData?.extractedData?.skills?.technical || [];
  if (technicalSkills.length < 5) {
    suggestions.push("Include more specific technical skills relevant to your target role");
  }

  // Check for soft skills
  const softSkills = resumeData?.extractedData?.skills?.soft || [];
  if (softSkills.length === 0) {
    suggestions.push("Consider adding soft skills like communication, teamwork, problem-solving, or leadership");
  }

  // Check for projects
  const projectsCount = resumeData?.extractedData?.projects?.length || 0;
  if (projectsCount === 0) {
    suggestions.push("Add relevant projects to demonstrate practical application of your skills");
  }

  // If no suggestions were added, provide general ones
  if (suggestions.length === 0) {
    suggestions.push(
      "Add specific metrics to quantify your achievements (e.g., 'increased efficiency by 30%', 'managed team of 5 developers')",
      "Include relevant certifications or online courses to show continuous learning",
      "Tailor your summary to the specific role you're targeting",
      "Emphasize leadership and teamwork experiences more prominently"
    );
  }

  return suggestions;
};

// Generate custom feedback
const generateCustomFeedback = (resumeData) => {
  const experienceCount = resumeData?.extractedData?.experience?.length || 0;
  const technicalSkillsCount = resumeData?.extractedData?.skills?.technical?.length || 0;
  const certificationsCount = resumeData?.extractedData?.certifications?.length || 0;
  const projectsCount = resumeData?.extractedData?.projects?.length || 0;
  const latestPosition = resumeData?.extractedData?.experience[0]?.position || 'your field';

  let feedback = `Based on your experience in ${latestPosition}, here's an assessment of your resume: `;

  if (experienceCount === 0) {
    feedback += "You have no work experience listed, which may impact your competitiveness. Consider adding internships, freelance work, or volunteer experiences. ";
  } else if (experienceCount < 2) {
    feedback += "You have limited work experience. Adding more relevant experience could strengthen your profile. ";
  } else {
    feedback += `You have ${experienceCount} positions of experience, which is a good foundation. `;
  }

  if (technicalSkillsCount < 5) {
    feedback += `You have ${technicalSkillsCount} technical skills listed. Consider adding more relevant technical skills to increase your match with job requirements. `;
  } else {
    feedback += "Your technical skills portfolio is well-rounded. ";
  }

  if (certificationsCount === 0) {
    feedback += "Consider pursuing relevant certifications to boost your credentials. ";
  } else {
    feedback += `You have ${certificationsCount} certifications, which adds credibility to your profile. `;
  }

  if (projectsCount === 0) {
    feedback += "Adding projects would demonstrate practical application of your skills. ";
  } else {
    feedback += `Your ${projectsCount} projects showcase hands-on experience. `;
  }

  feedback += "To improve your competitiveness for senior roles, focus on showcasing measurable impacts of your work and obtaining additional certifications in emerging technologies.";

  return feedback;
};

// Enhanced keyword matching service with backend priority
const matchKeywords = async (resumeData, jobDescription) => {
  try {
    const results = await matchJobDescriptionWithAI(resumeData, jobDescription);
    if (results) return results;
  } catch (error) {
    console.warn('AI matching service failed, falling back to simulation:', error);
  }

  // Fallback to simulated matching if AI fails
  return new Promise((resolve) => {
    setTimeout(() => {
      // Extract keywords from job description and resume
      const jobKeywords = extractKeywords(jobDescription);
      const resumeKeywords = resumeData?.extractedData?.skills?.technical || [];

      // Find matches and gaps
      const matched = resumeKeywords.filter(skill =>
        jobKeywords.some(keyword =>
          keyword.toLowerCase().includes(skill.toLowerCase()) ||
          skill.toLowerCase().includes(keyword.toLowerCase())
        )
      );

      const missing = jobKeywords.filter(keyword =>
        !resumeKeywords.some(skill =>
          keyword.toLowerCase().includes(skill.toLowerCase()) ||
          skill.toLowerCase().includes(keyword.toLowerCase())
        )
      ).slice(0, 10); // Limit to top 10 missing keywords

      const totalKeywords = matched.length + missing.length;
      const matchPercentage = totalKeywords > 0 ? Math.round((matched.length / totalKeywords) * 100) : 0;

      const result = {
        matchPercentage,
        matched,
        missing,
        totalJobKeywords: jobKeywords.length,
        totalResumeKeywords: resumeKeywords.length
      };

      resolve(result);
    }, 1500);
  });
};

// Helper function to extract keywords
const extractKeywords = (text) => {
  const commonKeywords = [
    'javascript', 'react', 'node.js', 'python', 'java', 'angular', 'vue', 'html', 'css',
    'sql', 'mongodb', 'express', 'api', 'rest', 'agile', 'scrum', 'git', 'github', 'docker',
    'kubernetes', 'aws', 'azure', 'gcp', 'ci/cd', 'testing', 'debugging', 'optimization',
    'leadership', 'communication', 'teamwork', 'problem-solving', 'design', 'architecture',
    'security', 'performance', 'scalability', 'microservices', 'devops', 'full-stack',
    'typescript', 'graphql', 'jest', 'redux', 'webpack', 'sass', 'bootstrap', 'material-ui',
    'postgresql', 'mysql', 'redis', 'elasticsearch', 'firebase', 'heroku', 'netlify'
  ];

  const lowerText = text.toLowerCase();
  return commonKeywords.filter(keyword => lowerText.includes(keyword));
};

// Healthcare education extraction
const extractHealthcareEducationFromFile = memoize((content) => {
  console.log("=== HEALTHCARE EDUCATION EXTRACTION ===");
  
  const healthcareEducationPatterns = [
    /(?:Medical Doctor|MD|Doctor of Medicine|Doctor of Osteopathic Medicine|DO|Bachelor of Science in Nursing|BSN|Registered Nurse|RN|Nurse Practitioner|NP|Physician Assistant|PA|Pharmacist|PharmD|Dentist|DDS|DMD|Veterinarian|DVM|Optometrist|OD|Physical Therapist|PT|Occupational Therapist|OT|Radiologic Technologist|RT|Medical Laboratory Scientist|MLS|Clinical Laboratory Scientist|CLS|Biomedical Engineer|BME|Healthcare Administrator|MHA|Master of Public Health|MPH|Epidemiology|Biostatistics|Clinical Research|Health Informatics)[\s\S]*?(?:at|from|of)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)(?:,|\.\s+\d{4}|\s+\d{4}|\s*-\s*\d{4}|\s+Graduated|\s+Completed)/gi,
    /(?:Harvard Medical School|Johns Hopkins School of Medicine|Mayo Clinic Alix School of Medicine|Duke University School of Medicine|Stanford University School of Medicine|University of Pennsylvania Perelman School of Medicine|Yale School of Medicine|Columbia University Vagelos College of Physicians and Surgeons|University of California San Francisco School of Medicine|Washington University School of Medicine|Northwestern University Feinberg School of Medicine|Vanderbilt University School of Medicine|University of Pittsburgh School of Medicine|University of Washington School of Medicine|University of Michigan Medical School|University of North Carolina School of Medicine|Emory University School of Medicine|University of California Los Angeles David Geffen School of Medicine|University of Texas Southwestern Medical School|Boston University School of Medicine)[\s\S]*?(?:\d{4}|Graduated|Completed)/gi,
    /(?:RN License|NCLEX-RN|Pharmacy Board Exam|USMLE|COMLEX|MCAT|DAT|OAT|PCAT|NBCRNA|NAPNES|CNA Certification|EMT Certification|Paramedic Certification|Surgical Tech Certification)[\s\S]*?(?:\d{4}|Passed|Obtained|Received)/gi
  ];
  
  const entries = [];
  healthcareEducationPatterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(content)) !== null) {
      const degree = match[0];
      const institution = match[1] || 'Healthcare Institution';
      
      entries.push({
        degree: degree,
        institution: institution,
        dates: extractDurationFromContext(content, match.index),
        grade: null
      });
    }
  });
  
  // If no specific healthcare education found, fall back to generic
  if (entries.length === 0) {
    return extractGenericEducation(content);
  }
  
  return entries;
});

// Education education extraction
const extractEducationEducationFromFile = memoize((content) => {
  console.log("=== EDUCATION EDUCATION EXTRACTION ===");
  
  const educationEducationPatterns = [
    /(?:Bachelor of Education|B.Ed|Master of Education|M.Ed|Doctor of Education|Ed.D|Ph.D in Education|Education Specialist|Ed.S|Curriculum and Instruction|Educational Leadership|Educational Psychology|Special Education|Early Childhood Education|Elementary Education|Secondary Education|Higher Education Administration|Adult Education|TESOL|Teaching English as a Second Language|Educational Technology|Instructional Design|Educational Assessment|Educational Policy|School Counseling|Educational Administration)[\s\S]*?(?:at|from|of)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)(?:,|\.\s+\d{4}|\s+\d{4}|\s*-\s*\d{4}|\s+Graduated|\s+Completed)/gi,
    /(?:State University|Teachers College|School of Education|College of Education|Graduate School of Education|Teachers University|Education Institute)[\s\S]*?(?:\d{4}|Graduated|Completed)/gi,
    /(?:Teaching Certificate|State Teaching License|Praxis Exam|NBPTS Certification|TESOL Certificate|Early Childhood Development Certificate)[\s\S]*?(?:\d{4}|Passed|Obtained|Received)/gi
  ];
  
  const entries = [];
  educationEducationPatterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(content)) !== null) {
      const degree = match[0];
      const institution = match[1] || 'Education Institution';
      
      entries.push({
        degree: degree,
        institution: institution,
        dates: extractDurationFromContext(content, match.index),
        grade: null
      });
    }
  });
  
  // If no specific education education found, fall back to generic
  if (entries.length === 0) {
    return extractGenericEducation(content);
  }
  
  return entries;
});

// Business education extraction
const extractBusinessEducationFromFile = memoize((content) => {
  console.log("=== BUSINESS EDUCATION EXTRACTION ===");
  
  const businessEducationPatterns = [
    /(?:Bachelor of Business Administration|BBA|Master of Business Administration|MBA|Executive MBA|EMBA|Master of Finance|MSF|Master of Accounting|MACC|Master of Economics|MEcon|Master of International Business|MIB|Master of Supply Chain Management|MSCM|Master of Marketing|MM|Master of Entrepreneurship|ME|Master of Organizational Behavior|MOB|Master of Public Administration|MPA|Master of Public Policy|MPP|Master of Commerce|B.Com|Master of Commerce|M.Com|Chartered Financial Analyst|CFA|Certified Public Accountant|CPA|Project Management Professional|PMP|Six Sigma|Lean Management)[\s\S]*?(?:at|from|of)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)(?:,|\.\s+\d{4}|\s+\d{4}|\s*-\s*\d{4}|\s+Graduated|\s+Completed)/gi,
    /(?:Wharton School|Harvard Business School|Stanford Graduate School of Business|Booth School of Business|Sloan School of Management|Columbia Business School|Haas School of Business|Kellogg School of Management|Tuck School of Business|Yale School of Management|Darden School of Business|Fuqua School of Business|Ross School of Business|McCombs School of Business|Carroll School of Management|Marshall School of Business|Olin Business School|Simon Business School|Johnson School of Management|Smeal College of Business)[\s\S]*?(?:\d{4}|Graduated|Completed)/gi,
    /(?:CFA Charter|CPA License|PMP Certification|Six Sigma Black Belt|FRM Certification|CFP Certification|CISA Certification)[\s\S]*?(?:\d{4}|Passed|Obtained|Received)/gi
  ];
  
  const entries = [];
  businessEducationPatterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(content)) !== null) {
      const degree = match[0];
      const institution = match[1] || 'Business Institution';
      
      entries.push({
        degree: degree,
        institution: institution,
        dates: extractDurationFromContext(content, match.index),
        grade: null
      });
    }
  });
  
  // If no specific business education found, fall back to generic
  if (entries.length === 0) {
    return extractGenericEducation(content);
  }
  
  return entries;
});

// Engineering education extraction
const extractEngineeringEducationFromFile = memoize((content) => {
  console.log("=== ENGINEERING EDUCATION EXTRACTION ===");
  
  const engineeringEducationPatterns = [
    /(?:Bachelor of Engineering|B.Eng|Bachelor of Science in Engineering|BSE|Master of Engineering|M.Eng|Master of Science in Engineering|MSE|Doctor of Engineering|Eng.D|Ph.D in Engineering|Computer Engineering|Software Engineering|Electrical Engineering|Mechanical Engineering|Civil Engineering|Chemical Engineering|Biomedical Engineering|Aerospace Engineering|Industrial Engineering|Environmental Engineering|Materials Engineering|Nuclear Engineering|Petroleum Engineering|Systems Engineering|Data Engineering|Network Engineering)[\s\S]*?(?:at|from|of)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)(?:,|\.\s+\d{4}|\s+\d{4}|\s*-\s*\d{4}|\s+Graduated|\s+Completed)/gi,
    /(?:MIT|Stanford|Caltech|Berkeley|CMU|Georgia Tech|UIUC|UMich|Purdue|Cornell|Columbia|Harvard|Princeton|Yale|Brown|UPenn|Dartmouth|Johns Hopkins|Northwestern|Washington University)[\s\S]*?Engineering[\s\S]*?(?:\d{4}|Graduated|Completed)/gi,
    /(?:PE License|EIT Certification|Fundamentals of Engineering|FE Exam|Professional Engineer|Engineer-in-Training|IEEE Certification|ASME Certification|AWS Certification|Cisco Certification|CompTIA|ISC Certification)[\s\S]*?(?:\d{4}|Passed|Obtained|Received)/gi
  ];
  
  const entries = [];
  engineeringEducationPatterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(content)) !== null) {
      const degree = match[0];
      const institution = match[1] || 'Engineering Institution';
      
      entries.push({
        degree: degree,
        institution: institution,
        dates: extractDurationFromContext(content, match.index),
        grade: null
      });
    }
  });
  
  // If no specific engineering education found, fall back to generic
  if (entries.length === 0) {
    return extractGenericEducation(content);
  }
  
  return entries;
});

// Creative education extraction
const extractCreativeEducationFromFile = memoize((content) => {
  console.log("=== CREATIVE EDUCATION EXTRACTION ===");
  
  const creativeEducationPatterns = [
    /(?:Bachelor of Fine Arts|BFA|Master of Fine Arts|MFA|Bachelor of Arts in Art|BA Art|Bachelor of Design|B.Des|Master of Design|M.Des|Bachelor of Architecture|B.Arch|Master of Architecture|M.Arch|Bachelor of Music|BMus|Bachelor of Arts in Graphic Design|Photography|Film Production|Digital Media|Animation|Interior Design|Fashion Design|Industrial Design|Game Design|Multimedia Arts|Visual Communications|Art History|Studio Art|Ceramics|Sculpture|Painting|Drawing|Printmaking|Digital Art|Web Design|UX Design|UI Design)[\s\S]*?(?:at|from|of)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)(?:,|\.\s+\d{4}|\s+\d{4}|\s*-\s*\d{4}|\s+Graduated|\s+Completed)/gi,
    /(?:Rhode Island School of Design|RISD|California Institute of the Arts|CalArts|Savannah College of Art and Design|SCAD|Parsons School of Design|Pratt Institute|Art Center College of Design|School of Visual Arts|SVA|Cranbrook Academy of Art|Otis College of Art and Design|Maryland Institute College of Art|MICA|Academy of Art University|New York Film Academy|NYFA|Full Sail University)[\s\S]*?(?:\d{4}|Graduated|Completed)/gi,
    /(?:Adobe Certified Expert|ACE|Autodesk Certification|Avid Certified Professional|Apple Certified Pro|Final Cut Pro|Avid Media Composer|Logic Pro|Pro Tools Operator|Digital Marketing Certification|Social Media Certification)[\s\S]*?(?:\d{4}|Passed|Obtained|Received)/gi
  ];
  
  const entries = [];
  creativeEducationPatterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(content)) !== null) {
      const degree = match[0];
      const institution = match[1] || 'Creative Institution';
      
      entries.push({
        degree: degree,
        institution: institution,
        dates: extractDurationFromContext(content, match.index),
        grade: null
      });
    }
  });
  
  // If no specific creative education found, fall back to generic
  if (entries.length === 0) {
    return extractGenericEducation(content);
  }
  
  return entries;
});

// Generic education extraction
const extractGenericEducation = (content) => {
  console.log("=== GENERIC EDUCATION EXTRACTION ===");
  
  // Look for education sections with more precise boundaries
  const educationPatterns = [
    // Primary pattern - strict section boundaries
    /(?:^|
)\s*(EDUCATION|ACADEMIC BACKGROUND|EDUCATIONAL BACKGROUND|ACADEMIC QUALIFICATIONS|EDUCATION HISTORY)\s*(?:
|\r
|\r|$)[\s\S]*?(?=
\s*(?:EXPERIENCE|WORK EXPERIENCE|PROFESSIONAL EXPERIENCE|SKILLS|TECHNICAL SKILLS|CERTIFICATES?|AWARDS?|PROJECTS|LANGUAGES|INTERESTS?|WORK|CONTACT|NAME|PROFILE)\s*(?:
|\r
|\r|$)|$)/i,
    // Secondary pattern - degree-specific with stricter boundaries
    /(?:MATRIC|INTERMEDIATE|BACHELOR|MASTER|PHD|DOCTORATE)[\s\S]*?(?=EXPERIENCE|WORK EXPERIENCE|PROFESSIONAL EXPERIENCE|SKILLS|TECHNICAL SKILLS|CERTIFICATES?|AWARDS?|PROJECTS|LANGUAGES|INTERESTS?|WORK|CONTACT|NAME|PROFILE|$)/i
  ];

  let educationText = '';
  
  // Try to find education section
  for (const pattern of educationPatterns) {
    const match = content.match(pattern);
    if (match) {
      educationText = match[0];
      break;
    }
  }

  // If no section found, use the entire content
  if (!educationText) {
    educationText = content;
  }

  const educationEntries = [];
  const lines = educationText.split('\n').map(l => l.trim()).filter(l => l.length > 3);

  // Define comprehensive education keywords
  const degreeKeywords = [
    'Matric', 'Matriculation', 'O Levels', 'SSC',
    'Intermediate', 'Inter', 'A Levels', 'HSC',
    'Bachelor', 'Bachelors', 'BS', 'BA', 'BSc', 'BE', 'BEng', 'BBA', 'BCA',
    'Master', 'Masters', 'MS', 'MA', 'MSc', 'ME', 'MEng', 'MBA', 'MCA',
    'PhD', 'Doctorate', 'Doctor', 'MPhil',
    'Associate', 'Diploma', 'Certificate', 'Certification',
    'MD', 'JD', 'LLB', 'LLM', 'MDS', 'BDS'
  ];

  const schoolKeywords = [
    'University', 'College', 'School', 'Institute', 'Academy', 'Campus', 'Polytechnic',
    'Board', 'Education Board', 'High School', 'Secondary School', 'Primary School'
  ];

  // Process each line looking for education entries
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Check if line contains education-related keywords
    const hasDegree = degreeKeywords.some(keyword => 
      line.toLowerCase().includes(keyword.toLowerCase())
    );
    const hasSchool = schoolKeywords.some(keyword => 
      line.toLowerCase().includes(keyword.toLowerCase())
    );
    
    if (hasDegree || hasSchool) {
      const entry = {
        institution: null,
        degree: null,
        dates: null,
        grade: null
      };

      // Extract dates
      const datePattern = /\b(?:\d{4}\s*[-\u2013\u2014]\s*\d{4}|\d{4}\s*(?:-|to|\u2013|\u2014)\s*(?:Present|Current|Now)|\d{4})\b/gi;
      const dateMatch = line.match(datePattern);
      if (dateMatch) {
        entry.dates = dateMatch[0];
      }

      // Extract grades/GPA
      const gradePatterns = [
        /(?:GPA|CGPA|Grade|Percentage|Score)[:\s]*([\d\.]+\s*(?:out of\s*[\d\.]+)?%?)/i,
        /([\d\.]+)\s*(?:out of\s*[\d\.]+)?\s*GPA/i,
        /(?:First|Second|Third|Fourth)\s+(?:Class|Division)/i
      ];
      
      for (const pattern of gradePatterns) {
        const gradeMatch = line.match(pattern);
        if (gradeMatch) {
          entry.grade = gradeMatch[0];
          break;
        }
      }

      // Look for institution and degree patterns
      const patterns = [
        // Pattern: Degree at Institution
        /^(.*?)\s+(?:at|@|in)\s+(.+)$/i,
        
        // Pattern: Institution - Degree
        /^(.*?)\s*[-|:]\s*(.+)$/,
        
        // Pattern: Institution, Degree
        /^(.*?),\s*(.+)$/,
        
        // Pattern: Degree | Institution
        /^(.*?)\s*\|\s*(.+)$/,
        
        // Pattern: Institution (Degree)
        /^(.*?)\s*\(([^)]+)\)$/,
      ];

      let matched = false;
      for (const pattern of patterns) {
        const match = line.match(pattern);
        if (match && match.length >= 3) {
          const part1 = match[1].trim();
          const part2 = match[2].trim();
          
          // Determine which is degree and which is institution
          const part1Lower = part1.toLowerCase();
          const part2Lower = part2.toLowerCase();
          
          const part1IsDegree = degreeKeywords.some(k => part1Lower.includes(k.toLowerCase()));
          const part2IsDegree = degreeKeywords.some(k => part2Lower.includes(k.toLowerCase()));
          const part1IsSchool = schoolKeywords.some(k => part1Lower.includes(k.toLowerCase()));
          const part2IsSchool = schoolKeywords.some(k => part2Lower.includes(k.toLowerCase()));
          
          if (part1IsDegree || part2IsSchool) {
            entry.degree = part1;
            entry.institution = part2;
            matched = true;
            break;
          } else if (part2IsDegree || part1IsSchool) {
            entry.degree = part2;
            entry.institution = part1;
            matched = true;
            break;
          }
        }
      }

      // If no pattern matched, try to identify parts separately
      if (!matched) {
        if (hasDegree && !entry.degree) {
          entry.degree = line;
        }
        if (hasSchool && !entry.institution) {
          entry.institution = line;
        }
      }

      // Add entry if we have meaningful data
      if (entry.degree || entry.institution) {
        educationEntries.push({
          institution: entry.institution || 'Institution Not Specified',
          degree: entry.degree || 'Degree Not Specified',
          dates: entry.dates || 'Dates Not Specified',
          grade: entry.grade || 'Grade Not Specified'
        });
      }
    }
  }

  console.log("Debug - Generic education entries found:", educationEntries);
  return educationEntries.length > 0 ? educationEntries : [];
};

// Section Identification Helper
const identifyResumeSections = (content) => {
  const sections = {};
  
  // Define section patterns with precise boundaries - match at start of line or after whitespace
  // Also match spaced-out versions like "E D U C A T I O N" or "S K I L L S"
  const sectionPatterns = {
    profile: /^(?:\s*PROFILES?|\s*ABOUT|\s*OBJECTIVE|\s*SUMMARY|\s*PERSONAL STATEMENT|\s*PROFESSIONAL SUMMARY|\s*CAREER SUMMARY|\s*P R O F I L E)/mi,
    education: /^(?:\s*EDUCATIONS?|\s*ACADEMIC BACKGROUND|\s*EDUCATIONAL BACKGROUND|\s*ACADEMIC QUALIFICATIONS|\s*EDUCATION HISTORY|\s*DEGREES?|\s*EDUCATION|\s*E D U C A T I O N)/mi,
    experience: /^(?:\s*EXPERIENCE|\s*WORK EXPERIENCE|\s*PROFESSIONAL EXPERIENCE|\s*EMPLOYMENT HISTORY|\s*PROFESSIONAL HISTORY|\s*E X P E R I E N C E)/mi,
    skills: /^(?:\s*SKILLS?|\s*TECHNICAL SKILLS?|\s*TECHNICAL COMPETENCIES?|\s*TECHNICAL PROFICIENCIES?|\s*KEY SKILLS?|\s*CORE COMPETENCIES?|\s*PROGRAMMING LANGUAGES?|\s*TECHNOLOGIES?|\s*TECH STACK|\s*K E Y S K I L L S|\s*S K I L L S|\s*T E C H N I C A L)/mi,
    projects: /^(?:\s*PROJECTS?|\s*KEY PROJECTS?|\s*NOTABLE PROJECTS?|\s*SOFTWARE PROJECTS?|\s*P R O J E C T S?)/mi,
    certifications: /^(?:\s*CERTIFICATES?|\s*CERTIFICATIONS?|\s*LICENSES?|\s*QUALIFICATIONS?|\s*PROFESSIONAL CERTIFICATIONS?|\s*C E R T I F I C A T E S?)/mi,
    awards: /^(?:\s*AWARDS?|\s*HONORS?|\s*RECOGNITIONS?|\s*ACHIEVEMENTS?|\s*A W A R D S?)/mi,
    languages: /^(?:\s*LANGUAGES?|\s*LANGUAGE SKILLS?|\s*L A N G U A G E S?)/mi,
    interests: /^(?:\s*INTERESTS?|\s*HOBBIES?|\s*ACTIVITIES?|\s*PERSONAL INTERESTS?|\s*I N T E R E S T S?)/mi,
    contact: /^(?:\s*CONTACT|\s*CONTACT INFORMATION|\s*PERSONAL DETAILS?|\s*ADDRESS|\s*C O N T A C T)/mi
  };
  
  // Normalize content by splitting into lines
  const lines = content.split(/\r?\n/);
  let currentSection = 'other';
  let sectionContent = [];
  
  // Process each line
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Check if this line is a section header
    let foundSection = null;
    for (const [sectionName, pattern] of Object.entries(sectionPatterns)) {
      if (pattern.test(line)) {
        foundSection = sectionName;
        break;
      }
    }
    
    if (foundSection) {
      // Save the previous section if it has content
      if (currentSection !== 'other' && sectionContent.length > 0) {
        sections[currentSection] = sectionContent.join('\n');
      }
      
      // Start new section
      currentSection = foundSection;
      sectionContent = [line];
    } else if (line && !/^\s*[\-\*\â€¢]+\s*$/.test(line)) {
      // Add to current section if it's not a blank line or separator
      sectionContent.push(line);
    }
  }
  
  // Save the last section
  if (currentSection !== 'other' && sectionContent.length > 0) {
    sections[currentSection] = sectionContent.join('\n');
  }
  
  // Handle cases where no clear sections were identified
  if (Object.keys(sections).length === 0 || (Object.keys(sections).length === 1 && sections.other)) {
    // If no sections found, try to identify them based on keywords and position in the content
    const upperContent = content.toUpperCase();
    
    // Find approximate positions of section indicators
    const educationPos = Math.max(
      upperContent.indexOf('EDUCATION'), 
      upperContent.indexOf('DEGREE'), 
      upperContent.indexOf('UNIVERSITY'), 
      upperContent.indexOf('COLLEGE')
    );
    
    const experiencePos = Math.max(
      upperContent.indexOf('EXPERIENCE'), 
      upperContent.indexOf('WORK'), 
      upperContent.indexOf('EMPLOYMENT'), 
      upperContent.indexOf('POSITION')
    );
    
    const skillsPos = Math.max(
      upperContent.indexOf('SKILL'), 
      upperContent.indexOf('TECHNICAL'), 
      upperContent.indexOf('PROGRAMMING'), 
      upperContent.indexOf('LANGUAGES')
    );
    
    // Extract content segments based on positions
    if (educationPos > -1) {
      let educationStart = educationPos;
      // Find the actual start of the education content (skip the header)
      const educationHeaderMatch = content.substring(educationPos).match(/^[\s\S]*?\n/m);
      if (educationHeaderMatch) {
        educationStart = educationPos + educationHeaderMatch[0].length;
      }
      
      let educationEnd = content.length;
      // Find next major section to define end
      const nextPositions = [];
      if (experiencePos > educationPos) nextPositions.push(experiencePos);
      if (skillsPos > educationPos) nextPositions.push(skillsPos);
      
      if (nextPositions.length > 0) {
        educationEnd = Math.min(...nextPositions);
      }
      
      sections.education = content.substring(educationStart, educationEnd).trim();
    }
    
    if (experiencePos > -1) {
      let experienceStart = experiencePos;
      // Find the actual start of the experience content (skip the header)
      const experienceHeaderMatch = content.substring(experiencePos).match(/^[\s\S]*?\n/m);
      if (experienceHeaderMatch) {
        experienceStart = experiencePos + experienceHeaderMatch[0].length;
      }
      
      let experienceEnd = content.length;
      // Find next major section to define end
      const nextPositions = [];
      if (skillsPos > experiencePos) nextPositions.push(skillsPos);
      
      if (nextPositions.length > 0) {
        experienceEnd = Math.min(...nextPositions);
      }
      
      sections.experience = content.substring(experienceStart, experienceEnd).trim();
    }
    
    if (skillsPos > -1) {
      let skillsStart = skillsPos;
      // Find the actual start of the skills content (skip the header)
      const skillsHeaderMatch = content.substring(skillsPos).match(/^[\s\S]*?\n/m);
      if (skillsHeaderMatch) {
        skillsStart = skillsPos + skillsHeaderMatch[0].length;
      }
      
      sections.skills = content.substring(skillsStart).trim();
    }
  }
  
  return sections;
};

export {
  parseResume,
  analyzeResume,
  matchKeywords
};












